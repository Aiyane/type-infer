简单类型推断器，基于逻辑式语言，使用简单数据结构所以效率并不高，后续可以替换更高效的数据结构。支持 number、boolean 类型，支持 not、zero?、sub1、+、*、if、fix、cons、car、cdr 与函数及函数应用操作的类型推断，示例如下。

```scheme
> (infer '#t)
(Bool)
> (infer '17)
(Nat)
> (infer '(zero? 24))
(Bool)
> (infer '(zero? (sub1 24)))
(Bool)
> (infer '(not (zero? (sub1 24))))
(Bool)
> (infer '(zero? (sub1 (sub1 18))))
(Bool)
> (infer '(lambda (n) (if (zero? n) n n)))
((Nat -> Nat))
> (infer '((lambda (n) (zero? n)) 5))
(Bool)
> (infer '(if (zero? 24) 3 4))
(Nat)
> (infer '(if (zero? 24) (zero? 3) (zero? 4)))
(Bool)
> (infer '(lambda (x) (sub1 x)))
((Nat -> Nat))
> (infer '(lambda (a) (lambda (x) (+ a x))))
((Nat -> (Nat -> Nat)))
> (infer '(lambda (f)
                   (lambda (x)
                     ((f x) x))))
(((_0 -> (_0 -> _1)) -> (_0 -> _1)))
> (infer '(sub1 (sub1 (sub1 6))))
(Nat)
> (infer '(lambda (f) (f f)))
()
> (infer '(cons (zero? 1) (zero? 0)))
((pairof Bool Bool))
> (infer '(cons (zero? 1) (cons (zero? 1) (zero? 0))))
((pairof Bool (pairof Bool Bool)))
> (infer '(lambda (x) (cons x x)))
((_0 -> (pairof _0 _0)))
> (infer '(lambda (x) (lambda (y) (cons (zero? x) (+ x y)))))
((Nat -> (Nat -> (pairof Bool Nat))))
> (infer '(lambda (x) (zero? (car x))))
(((pairof Nat _0) -> Bool))
> (infer '(lambda (x) (car x)))
(((pairof _0 _1) -> _0))
> (infer '((lambda (x) (zero? (car x))) (cons 0 1)))
(Bool)
> (infer '((lambda (x) (zero? (car x))) (cons 0 #f)))
(Bool)
> (infer '((lambda (x) (zero? (car x))) (cons #f 0)))
()
> (infer '(lambda (x) (zero? (cdr x))))
(((pairof _0 Nat) -> Bool))
> (infer '(lambda (x) (cdr x)))
(((pairof _0 _1) -> _1))
> (infer '((lambda (x) (zero? (cdr x))) (cons 0 1)))
(Bool)
> (infer '((lambda (x) (zero? (cdr x))) (cons 0 #f)))
()
> (infer '((lambda (x) (zero? (cdr x))) (cons #f 0)))
(Bool)
```
